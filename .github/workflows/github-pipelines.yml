name: Source & Build Stages

on:
  push:
    branches: 
      - main
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'plan'
        type: choice
        options:
          - plan
          - apply
          - destroy

jobs:
  build-and-push:
    name: Build and Push to ECR
    runs-on: ubuntu-latest
    # Only run this job when needed (e.g., when applying or when Docker files change)
    if: github.event.inputs.action == 'apply' || github.event_name == 'push'
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, Tag, and Push Image to ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: demo-app-images
          IMAGE_TAG: latest
        run: |
          cd docker
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

  terraform-plan:
    name: Terraform Plan
    needs: [build-and-push]  # This ensures Docker image is built first
    runs-on: ubuntu-22.04
    if: github.event_name == 'push' || github.event.inputs.action == 'plan' || github.event.inputs.action == 'apply'
    container:
      image: hashicorp/terraform:1.5.7          # It's always best to use a stable version of terraform as latest versions could cause issues within your pipeline in future.
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4         

      # We need to programmatically authenticate to AWS to ensure Terraform knows where to deploy the resources we have prepared.
      # Secondly, we need to ensure that the programmatic user is always assigned permissions using the principle of least privilege.
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # Here we initialize terraform and use the s3 bucket to manage our state and also call upon our DynamoDB table to perform session management in terms of state locking.
      # We then ask Terraform to perform a plan, which should provide us with a summary of the resources it's about to create.
      - name: Initialize Terraform
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" \
            -backend-config="key=terraform.tfstate" \
            -backend-config="region=${{ secrets.AWS_REGION }}" \
            -backend-config="access_key=${{ secrets.AWS_ACCESS_KEY_ID }}" \
            -backend-config="secret_key=${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
            -backend-config="dynamodb_table=${{ secrets.TF_STATE_LOCK_TABLE }}"

      - name: Terraform Plan
        run: terraform plan -out=tfplan

      - name: Upload Terraform Plan
        uses: actions/upload-artifact@v4
        with:
          name: tfplan
          path: tfplan
          retention-days: 1

  manual-approval:
    name: Manual Approval
    needs: terraform-plan
    runs-on: ubuntu-22.04
    if: github.event_name == 'push' || github.event.inputs.action == 'apply'  
    environment: 
      name: production
      url: https://github.com/${{ github.repository }}/actions/workflows/terraform.yml
    steps:
      - name: Approval Check
        run: echo "Deployment approved"

  terraform-apply:
    name: Terraform Apply
    needs: manual-approval
    runs-on: ubuntu-22.04
    # If triggered by push after manual approval.
    if: (github.event_name == 'push' && needs.manual-approval.result == 'success') || github.event.inputs.action == 'apply'
    environment: 
      name: production
      url: https://github.com/${{ github.repository }}/actions/workflows/terraform.yml
    container:
      image: hashicorp/terraform:1.5.7
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      # We need to programmatically authenticate to AWS to ensure Terraform knows where to deploy the resources we have prepared.
      # Secondly, we need to ensure that the programmatic user is always assigned permissions using the principle of least privilege.
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # Here we initialize terraform and use the s3 bucket to manage our state and also call upon our DynamoDB table to perform session management in terms of state locking.
      - name: Initialize Terraform
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" \
            -backend-config="key=terraform.tfstate" \
            -backend-config="region=${{ secrets.AWS_REGION }}" \
            -backend-config="access_key=${{ secrets.AWS_ACCESS_KEY_ID }}" \
            -backend-config="secret_key=${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
            -backend-config="dynamodb_table=${{ secrets.TF_STATE_LOCK_TABLE }}"

      - name: Download Terraform Plan
        uses: actions/download-artifact@v4
        with:
          name: tfplan

      # Finally, we apply the Terraform changes to create the resources in our AWS account.
      - name: Apply Terraform Changes
        run: terraform apply -auto-approve tfplan

      - name: Output EC2 Public IP
        run: terraform output ec2_public_ip

  terraform-destroy:
    name: Terraform Destroy
    runs-on: ubuntu-22.04
    if: github.event.inputs.action == 'destroy'
    environment: 
      name: production
      url: https://github.com/${{ github.repository }}/actions/workflows/terraform.yml
    container:
      image: hashicorp/terraform:1.5.7
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      # We need to programmatically authenticate to AWS to ensure Terraform knows where to deploy the resources we have prepared.
      # Secondly, we need to ensure that the programmatic user is always assigned permissions using the principle of least privilege.
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # Here we initialize terraform and use the s3 bucket to manage our state and also call upon our DynamoDB table to perform session management in terms of state locking.
      - name: Initialize Terraform
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" \
            -backend-config="key=terraform.tfstate" \
            -backend-config="region=${{ secrets.AWS_REGION }}" \
            -backend-config="access_key=${{ secrets.AWS_ACCESS_KEY_ID }}" \
            -backend-config="secret_key=${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
            -backend-config="dynamodb_table=${{ secrets.TF_STATE_LOCK_TABLE }}"

      # Destroy all infrastructure created by Terraform
      - name: Terraform Plan Destroy
        run: terraform plan -destroy -out=tfdestroyplan
  
      - name: Destroy Infrastructure
        run: terraform apply -auto-approve tfdestroyplan